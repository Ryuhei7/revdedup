<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>RevDedup: include/kclangc.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">RevDedup
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">Reverse Deduplication prototype</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">include/kclangc.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*************************************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"> * C language binding</span>
<a name="l00003"></a>00003 <span class="comment"> *                                                               Copyright (C) 2009-2012 FAL Labs</span>
<a name="l00004"></a>00004 <span class="comment"> * This file is part of Kyoto Cabinet.</span>
<a name="l00005"></a>00005 <span class="comment"> * This program is free software: you can redistribute it and/or modify it under the terms of</span>
<a name="l00006"></a>00006 <span class="comment"> * the GNU General Public License as published by the Free Software Foundation, either version</span>
<a name="l00007"></a>00007 <span class="comment"> * 3 of the License, or any later version.</span>
<a name="l00008"></a>00008 <span class="comment"> * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;</span>
<a name="l00009"></a>00009 <span class="comment"> * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<a name="l00010"></a>00010 <span class="comment"> * See the GNU General Public License for more details.</span>
<a name="l00011"></a>00011 <span class="comment"> * You should have received a copy of the GNU General Public License along with this program.</span>
<a name="l00012"></a>00012 <span class="comment"> * If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00013"></a>00013 <span class="comment"> *************************************************************************************************/</span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="preprocessor">#ifndef _KCLANGC_H                       </span><span class="comment">/* duplication check */</span>
<a name="l00017"></a>00017 <span class="preprocessor">#define _KCLANGC_H</span>
<a name="l00018"></a>00018 <span class="preprocessor"></span>
<a name="l00019"></a>00019 <span class="preprocessor">#if defined(__cplusplus)</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
<a name="l00021"></a>00021 <span class="preprocessor">#endif</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span>
<a name="l00023"></a>00023 <span class="preprocessor">#if !defined(__STDC_LIMIT_MACROS)</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span><span class="preprocessor">#define __STDC_LIMIT_MACROS  1           </span>
<a name="l00025"></a>00025 <span class="preprocessor">#endif</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;errno.h&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;float.h&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;limits.h&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;locale.h&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;setjmp.h&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;stddef.h&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;signal.h&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;time.h&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;stdint.h&gt;</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 
<a name="l00048"></a><a class="code" href="structKCDB.html">00048</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00049"></a><a class="code" href="structKCDB.html#a8828faedd093c54920e201c03712c2e0">00049</a>   <span class="keywordtype">void</span>* <a class="code" href="structKCDB.html#a8828faedd093c54920e201c03712c2e0">db</a>;                              
<a name="l00050"></a>00050 } <a class="code" href="structKCDB.html">KCDB</a>;
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 
<a name="l00056"></a><a class="code" href="structKCCUR.html">00056</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00057"></a><a class="code" href="structKCCUR.html#a521b6ac64c18efec3e4b989a41bbe282">00057</a>   <span class="keywordtype">void</span>* <a class="code" href="structKCCUR.html#a521b6ac64c18efec3e4b989a41bbe282">cur</a>;                             
<a name="l00058"></a>00058 } <a class="code" href="structKCCUR.html">KCCUR</a>;
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 
<a name="l00064"></a><a class="code" href="structKCSTR.html">00064</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00065"></a><a class="code" href="structKCSTR.html#a3cc2ddd4f31e396186c58f4c4af1be95">00065</a>   <span class="keywordtype">char</span>* <a class="code" href="structKCSTR.html#a3cc2ddd4f31e396186c58f4c4af1be95">buf</a>;                             
<a name="l00066"></a><a class="code" href="structKCSTR.html#ad3cb793e9eaacf8dfec9b8a0c4dfc98c">00066</a>   <span class="keywordtype">size_t</span> <a class="code" href="structKCSTR.html#ad3cb793e9eaacf8dfec9b8a0c4dfc98c">size</a>;                           
<a name="l00067"></a>00067 } <a class="code" href="structKCSTR.html">KCSTR</a>;
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 
<a name="l00073"></a><a class="code" href="structKCREC.html">00073</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00074"></a><a class="code" href="structKCREC.html#a0a1dd7a77ca0ae233e3a0f54c5f66139">00074</a>   <a class="code" href="structKCSTR.html">KCSTR</a> <a class="code" href="structKCREC.html#a0a1dd7a77ca0ae233e3a0f54c5f66139">key</a>;                             
<a name="l00075"></a><a class="code" href="structKCREC.html#a8dbf8ff1432c43c631f077529f1846bf">00075</a>   <a class="code" href="structKCSTR.html">KCSTR</a> <a class="code" href="structKCREC.html#a8dbf8ff1432c43c631f077529f1846bf">value</a>;                           
<a name="l00076"></a>00076 } <a class="code" href="structKCREC.html">KCREC</a>;
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 
<a name="l00082"></a>00082 <span class="keyword">enum</span> {
<a name="l00083"></a>00083   KCESUCCESS,                            
<a name="l00084"></a>00084   KCENOIMPL,                             
<a name="l00085"></a>00085   KCEINVALID,                            
<a name="l00086"></a>00086   KCENOREPOS,                            
<a name="l00087"></a>00087   KCENOPERM,                             
<a name="l00088"></a>00088   KCEBROKEN,                             
<a name="l00089"></a>00089   KCEDUPREC,                             
<a name="l00090"></a>00090   KCENOREC,                              
<a name="l00091"></a>00091   KCELOGIC,                              
<a name="l00092"></a>00092   KCESYSTEM,                             
<a name="l00093"></a>00093   KCEMISC = 15                           
<a name="l00094"></a>00094 };
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 
<a name="l00100"></a>00100 <span class="keyword">enum</span> {
<a name="l00101"></a>00101   KCOREADER = 1 &lt;&lt; 0,                    
<a name="l00102"></a>00102   KCOWRITER = 1 &lt;&lt; 1,                    
<a name="l00103"></a>00103   KCOCREATE = 1 &lt;&lt; 2,                    
<a name="l00104"></a>00104   KCOTRUNCATE = 1 &lt;&lt; 3,                  
<a name="l00105"></a>00105   KCOAUTOTRAN = 1 &lt;&lt; 4,                  
<a name="l00106"></a>00106   KCOAUTOSYNC = 1 &lt;&lt; 5,                  
<a name="l00107"></a>00107   KCONOLOCK = 1 &lt;&lt; 6,                    
<a name="l00108"></a>00108   KCOTRYLOCK = 1 &lt;&lt; 7,                   
<a name="l00109"></a>00109   KCONOREPAIR = 1 &lt;&lt; 8                   
<a name="l00110"></a>00110 };
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 
<a name="l00116"></a>00116 <span class="keyword">enum</span> {
<a name="l00117"></a>00117   KCMSET,                                
<a name="l00118"></a>00118   KCMADD,                                
<a name="l00119"></a>00119   KCMREPLACE,                            
<a name="l00120"></a>00120   KCMAPPEND                              
<a name="l00121"></a>00121 };
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 
<a name="l00125"></a>00125 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> KCVERSION;
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 
<a name="l00129"></a>00129 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> KCVISNOP;
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 
<a name="l00133"></a>00133 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> KCVISREMOVE;
<a name="l00134"></a>00134 
<a name="l00135"></a>00135 
<a name="l00148"></a>00148 <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* (*KCVISITFULL)(<span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz,
<a name="l00149"></a>00149                                    <span class="keyword">const</span> <span class="keywordtype">char</span>* vbuf, <span class="keywordtype">size_t</span> vsiz, <span class="keywordtype">size_t</span>* sp, <span class="keywordtype">void</span>* opq);
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 
<a name="l00162"></a>00162 <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* (*KCVISITEMPTY)(<span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz, <span class="keywordtype">size_t</span>* sp, <span class="keywordtype">void</span>* opq);
<a name="l00163"></a>00163 
<a name="l00164"></a>00164 
<a name="l00173"></a>00173 <span class="keyword">typedef</span> int32_t (*KCFILEPROC)(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, int64_t count, int64_t size, <span class="keywordtype">void</span>* opq);
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 
<a name="l00182"></a>00182 <span class="keywordtype">void</span>* kcmalloc(<span class="keywordtype">size_t</span> size);
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 
<a name="l00189"></a>00189 <span class="keywordtype">void</span> kcfree(<span class="keywordtype">void</span>* ptr);
<a name="l00190"></a>00190 
<a name="l00191"></a>00191 
<a name="l00196"></a>00196 <span class="keywordtype">double</span> kctime(<span class="keywordtype">void</span>);
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 
<a name="l00204"></a>00204 int64_t kcatoi(<span class="keyword">const</span> <span class="keywordtype">char</span>* str);
<a name="l00205"></a>00205 
<a name="l00206"></a>00206 
<a name="l00215"></a>00215 int64_t kcatoix(<span class="keyword">const</span> <span class="keywordtype">char</span>* str);
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 
<a name="l00224"></a>00224 <span class="keywordtype">double</span> kcatof(<span class="keyword">const</span> <span class="keywordtype">char</span>* str);
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 
<a name="l00233"></a>00233 uint64_t kchashmurmur(<span class="keyword">const</span> <span class="keywordtype">void</span>* buf, <span class="keywordtype">size_t</span> size);
<a name="l00234"></a>00234 
<a name="l00235"></a>00235 
<a name="l00242"></a>00242 uint64_t kchashfnv(<span class="keyword">const</span> <span class="keywordtype">void</span>* buf, <span class="keywordtype">size_t</span> size);
<a name="l00243"></a>00243 
<a name="l00244"></a>00244 
<a name="l00254"></a>00254 <span class="keywordtype">size_t</span> kclevdist(<span class="keyword">const</span> <span class="keywordtype">void</span>* abuf, <span class="keywordtype">size_t</span> asiz, <span class="keyword">const</span> <span class="keywordtype">void</span>* bbuf, <span class="keywordtype">size_t</span> bsiz, int32_t utf);
<a name="l00255"></a>00255 
<a name="l00256"></a>00256 
<a name="l00261"></a>00261 <span class="keywordtype">double</span> kcnan();
<a name="l00262"></a>00262 
<a name="l00263"></a>00263 
<a name="l00268"></a>00268 <span class="keywordtype">double</span> kcinf();
<a name="l00269"></a>00269 
<a name="l00270"></a>00270 
<a name="l00275"></a>00275 int32_t kcchknan(<span class="keywordtype">double</span> num);
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 
<a name="l00282"></a>00282 int32_t kcchkinf(<span class="keywordtype">double</span> num);
<a name="l00283"></a>00283 
<a name="l00284"></a>00284 
<a name="l00290"></a>00290 <span class="keyword">const</span> <span class="keywordtype">char</span>* kcecodename(int32_t code);
<a name="l00291"></a>00291 
<a name="l00292"></a>00292 
<a name="l00299"></a>00299 <a class="code" href="structKCDB.html">KCDB</a>* kcdbnew(<span class="keywordtype">void</span>);
<a name="l00300"></a>00300 
<a name="l00301"></a>00301 
<a name="l00306"></a>00306 <span class="keywordtype">void</span> kcdbdel(<a class="code" href="structKCDB.html">KCDB</a>* db);
<a name="l00307"></a>00307 
<a name="l00308"></a>00308 
<a name="l00363"></a>00363 int32_t kcdbopen(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <span class="keywordtype">char</span>* path, uint32_t mode);
<a name="l00364"></a>00364 
<a name="l00365"></a>00365 
<a name="l00371"></a>00371 int32_t kcdbclose(<a class="code" href="structKCDB.html">KCDB</a>* db);
<a name="l00372"></a>00372 
<a name="l00373"></a>00373 
<a name="l00379"></a>00379 int32_t kcdbecode(<a class="code" href="structKCDB.html">KCDB</a>* db);
<a name="l00380"></a>00380 
<a name="l00381"></a>00381 
<a name="l00387"></a>00387 <span class="keyword">const</span> <span class="keywordtype">char</span>* kcdbemsg(<a class="code" href="structKCDB.html">KCDB</a>* db);
<a name="l00388"></a>00388 
<a name="l00389"></a>00389 
<a name="l00404"></a>00404 int32_t kcdbaccept(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz,
<a name="l00405"></a>00405                    KCVISITFULL fullproc, KCVISITEMPTY emptyproc, <span class="keywordtype">void</span>* opq, int32_t writable);
<a name="l00406"></a>00406 
<a name="l00407"></a>00407 
<a name="l00422"></a>00422 int32_t kcdbacceptbulk(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <a class="code" href="structKCSTR.html">KCSTR</a>* keys, <span class="keywordtype">size_t</span> knum,
<a name="l00423"></a>00423                        KCVISITFULL fullproc, KCVISITEMPTY emptyproc,
<a name="l00424"></a>00424                        <span class="keywordtype">void</span>* opq, int32_t writable);
<a name="l00425"></a>00425 
<a name="l00426"></a>00426 
<a name="l00437"></a>00437 int32_t kcdbiterate(<a class="code" href="structKCDB.html">KCDB</a>* db, KCVISITFULL fullproc, <span class="keywordtype">void</span>* opq, int32_t writable);
<a name="l00438"></a>00438 
<a name="l00439"></a>00439 
<a name="l00451"></a>00451 int32_t kcdbscanpara(<a class="code" href="structKCDB.html">KCDB</a>* db, KCVISITFULL fullproc, <span class="keywordtype">void</span>* opq, <span class="keywordtype">size_t</span> thnum);
<a name="l00452"></a>00452 
<a name="l00453"></a>00453 
<a name="l00465"></a>00465 int32_t kcdbset(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz, <span class="keyword">const</span> <span class="keywordtype">char</span>* vbuf, <span class="keywordtype">size_t</span> vsiz);
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 
<a name="l00479"></a>00479 int32_t kcdbadd(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz, <span class="keyword">const</span> <span class="keywordtype">char</span>* vbuf, <span class="keywordtype">size_t</span> vsiz);
<a name="l00480"></a>00480 
<a name="l00481"></a>00481 
<a name="l00493"></a>00493 int32_t kcdbreplace(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz, <span class="keyword">const</span> <span class="keywordtype">char</span>* vbuf, <span class="keywordtype">size_t</span> vsiz);
<a name="l00494"></a>00494 
<a name="l00495"></a>00495 
<a name="l00507"></a>00507 int32_t kcdbappend(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz, <span class="keyword">const</span> <span class="keywordtype">char</span>* vbuf, <span class="keywordtype">size_t</span> vsiz);
<a name="l00508"></a>00508 
<a name="l00509"></a>00509 
<a name="l00523"></a>00523 int64_t kcdbincrint(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz, int64_t num, int64_t orig);
<a name="l00524"></a>00524 
<a name="l00525"></a>00525 
<a name="l00539"></a>00539 <span class="keywordtype">double</span> kcdbincrdouble(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz, <span class="keywordtype">double</span> num, <span class="keywordtype">double</span> orig);
<a name="l00540"></a>00540 
<a name="l00541"></a>00541 
<a name="l00553"></a>00553 int32_t kcdbcas(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz,
<a name="l00554"></a>00554                 <span class="keyword">const</span> <span class="keywordtype">char</span>* ovbuf, <span class="keywordtype">size_t</span> ovsiz, <span class="keyword">const</span> <span class="keywordtype">char</span>* nvbuf, <span class="keywordtype">size_t</span> nvsiz);
<a name="l00555"></a>00555 
<a name="l00556"></a>00556 
<a name="l00565"></a>00565 int32_t kcdbremove(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz);
<a name="l00566"></a>00566 
<a name="l00567"></a>00567 
<a name="l00581"></a>00581 <span class="keywordtype">char</span>* kcdbget(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz, <span class="keywordtype">size_t</span>* sp);
<a name="l00582"></a>00582 
<a name="l00583"></a>00583 
<a name="l00591"></a>00591 int32_t kcdbcheck(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz);
<a name="l00592"></a>00592 
<a name="l00593"></a>00593 
<a name="l00604"></a>00604 int32_t kcdbgetbuf(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz, <span class="keywordtype">char</span>* vbuf, <span class="keywordtype">size_t</span> max);
<a name="l00605"></a>00605 
<a name="l00606"></a>00606 
<a name="l00620"></a>00620 <span class="keywordtype">char</span>* kcdbseize(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz, <span class="keywordtype">size_t</span>* sp);
<a name="l00621"></a>00621 
<a name="l00622"></a>00622 
<a name="l00631"></a>00631 int64_t kcdbsetbulk(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <a class="code" href="structKCREC.html">KCREC</a>* recs, <span class="keywordtype">size_t</span> rnum, int32_t atomic);
<a name="l00632"></a>00632 
<a name="l00633"></a>00633 
<a name="l00642"></a>00642 int64_t kcdbremovebulk(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <a class="code" href="structKCSTR.html">KCSTR</a>* keys, <span class="keywordtype">size_t</span> knum, int32_t atomic);
<a name="l00643"></a>00643 
<a name="l00644"></a>00644 
<a name="l00656"></a>00656 int64_t kcdbgetbulk(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <a class="code" href="structKCSTR.html">KCSTR</a>* keys, <span class="keywordtype">size_t</span> knum, <a class="code" href="structKCREC.html">KCREC</a>* recs, int32_t atomic);
<a name="l00657"></a>00657 
<a name="l00658"></a>00658 
<a name="l00672"></a>00672 int32_t kcdbsync(<a class="code" href="structKCDB.html">KCDB</a>* db, int32_t hard, KCFILEPROC proc, <span class="keywordtype">void</span>* opq);
<a name="l00673"></a>00673 
<a name="l00674"></a>00674 
<a name="l00686"></a>00686 int32_t kcdboccupy(<a class="code" href="structKCDB.html">KCDB</a>* db, int32_t writable, KCFILEPROC proc, <span class="keywordtype">void</span>* opq);
<a name="l00687"></a>00687 
<a name="l00688"></a>00688 
<a name="l00695"></a>00695 int32_t kcdbcopy(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <span class="keywordtype">char</span>* dest);
<a name="l00696"></a>00696 
<a name="l00697"></a>00697 
<a name="l00705"></a>00705 int32_t kcdbbegintran(<a class="code" href="structKCDB.html">KCDB</a>* db, int32_t hard);
<a name="l00706"></a>00706 
<a name="l00707"></a>00707 
<a name="l00715"></a>00715 int32_t kcdbbegintrantry(<a class="code" href="structKCDB.html">KCDB</a>* db, int32_t hard);
<a name="l00716"></a>00716 
<a name="l00717"></a>00717 
<a name="l00724"></a>00724 int32_t kcdbendtran(<a class="code" href="structKCDB.html">KCDB</a>* db, int32_t commit);
<a name="l00725"></a>00725 
<a name="l00726"></a>00726 
<a name="l00732"></a>00732 int32_t kcdbclear(<a class="code" href="structKCDB.html">KCDB</a>* db);
<a name="l00733"></a>00733 
<a name="l00734"></a>00734 
<a name="l00741"></a>00741 int32_t kcdbdumpsnap(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <span class="keywordtype">char</span>* dest);
<a name="l00742"></a>00742 
<a name="l00743"></a>00743 
<a name="l00750"></a>00750 int32_t kcdbloadsnap(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <span class="keywordtype">char</span>* src);
<a name="l00751"></a>00751 
<a name="l00752"></a>00752 
<a name="l00758"></a>00758 int64_t kcdbcount(<a class="code" href="structKCDB.html">KCDB</a>* db);
<a name="l00759"></a>00759 
<a name="l00760"></a>00760 
<a name="l00766"></a>00766 int64_t kcdbsize(<a class="code" href="structKCDB.html">KCDB</a>* db);
<a name="l00767"></a>00767 
<a name="l00768"></a>00768 
<a name="l00776"></a>00776 <span class="keywordtype">char</span>* kcdbpath(<a class="code" href="structKCDB.html">KCDB</a>* db);
<a name="l00777"></a>00777 
<a name="l00778"></a>00778 
<a name="l00787"></a>00787 <span class="keywordtype">char</span>* kcdbstatus(<a class="code" href="structKCDB.html">KCDB</a>* db);
<a name="l00788"></a>00788 
<a name="l00789"></a>00789 
<a name="l00800"></a>00800 int64_t kcdbmatchprefix(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <span class="keywordtype">char</span>* prefix, <span class="keywordtype">char</span>** strary, <span class="keywordtype">size_t</span> max);
<a name="l00801"></a>00801 
<a name="l00802"></a>00802 
<a name="l00813"></a>00813 int64_t kcdbmatchregex(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <span class="keywordtype">char</span>* regex, <span class="keywordtype">char</span>** strary, <span class="keywordtype">size_t</span> max);
<a name="l00814"></a>00814 
<a name="l00815"></a>00815 
<a name="l00828"></a>00828 int64_t kcdbmatchsimilar(<a class="code" href="structKCDB.html">KCDB</a>* db, <span class="keyword">const</span> <span class="keywordtype">char</span>* origin, uint32_t range, int32_t utf,
<a name="l00829"></a>00829                          <span class="keywordtype">char</span>** strary, <span class="keywordtype">size_t</span> max);
<a name="l00830"></a>00830 
<a name="l00831"></a>00831 
<a name="l00842"></a>00842 int32_t kcdbmerge(<a class="code" href="structKCDB.html">KCDB</a>* db, <a class="code" href="structKCDB.html">KCDB</a>** srcary, <span class="keywordtype">size_t</span> srcnum, uint32_t mode);
<a name="l00843"></a>00843 
<a name="l00844"></a>00844 
<a name="l00852"></a>00852 <a class="code" href="structKCCUR.html">KCCUR</a>* kcdbcursor(<a class="code" href="structKCDB.html">KCDB</a>* db);
<a name="l00853"></a>00853 
<a name="l00854"></a>00854 
<a name="l00859"></a>00859 <span class="keywordtype">void</span> kccurdel(<a class="code" href="structKCCUR.html">KCCUR</a>* cur);
<a name="l00860"></a>00860 
<a name="l00861"></a>00861 
<a name="l00874"></a>00874 int32_t kccuraccept(<a class="code" href="structKCCUR.html">KCCUR</a>* cur, KCVISITFULL fullproc, <span class="keywordtype">void</span>* opq,
<a name="l00875"></a>00875                     int32_t writable, int32_t step);
<a name="l00876"></a>00876 
<a name="l00877"></a>00877 
<a name="l00886"></a>00886 int32_t kccursetvalue(<a class="code" href="structKCCUR.html">KCCUR</a>* cur, <span class="keyword">const</span> <span class="keywordtype">char</span>* vbuf, <span class="keywordtype">size_t</span> vsiz, int32_t step);
<a name="l00887"></a>00887 
<a name="l00888"></a>00888 
<a name="l00896"></a>00896 int32_t kccurremove(<a class="code" href="structKCCUR.html">KCCUR</a>* cur);
<a name="l00897"></a>00897 
<a name="l00898"></a>00898 
<a name="l00911"></a>00911 <span class="keywordtype">char</span>* kccurgetkey(<a class="code" href="structKCCUR.html">KCCUR</a>* cur, <span class="keywordtype">size_t</span>* sp, int32_t step);
<a name="l00912"></a>00912 
<a name="l00913"></a>00913 
<a name="l00926"></a>00926 <span class="keywordtype">char</span>* kccurgetvalue(<a class="code" href="structKCCUR.html">KCCUR</a>* cur, <span class="keywordtype">size_t</span>* sp, int32_t step);
<a name="l00927"></a>00927 
<a name="l00928"></a>00928 
<a name="l00945"></a>00945 <span class="keywordtype">char</span>* kccurget(<a class="code" href="structKCCUR.html">KCCUR</a>* cur, <span class="keywordtype">size_t</span>* ksp, <span class="keyword">const</span> <span class="keywordtype">char</span>** vbp, <span class="keywordtype">size_t</span>* vsp, int32_t step);
<a name="l00946"></a>00946 
<a name="l00947"></a>00947 
<a name="l00963"></a>00963 <span class="keywordtype">char</span>* kccurseize(<a class="code" href="structKCCUR.html">KCCUR</a>* cur, <span class="keywordtype">size_t</span>* ksp, <span class="keyword">const</span> <span class="keywordtype">char</span>** vbp, <span class="keywordtype">size_t</span>* vsp);
<a name="l00964"></a>00964 
<a name="l00965"></a>00965 
<a name="l00971"></a>00971 int32_t kccurjump(<a class="code" href="structKCCUR.html">KCCUR</a>* cur);
<a name="l00972"></a>00972 
<a name="l00973"></a>00973 
<a name="l00981"></a>00981 int32_t kccurjumpkey(<a class="code" href="structKCCUR.html">KCCUR</a>* cur, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz);
<a name="l00982"></a>00982 
<a name="l00983"></a>00983 
<a name="l00991"></a>00991 int32_t kccurjumpback(<a class="code" href="structKCCUR.html">KCCUR</a>* cur);
<a name="l00992"></a>00992 
<a name="l00993"></a>00993 
<a name="l01003"></a>01003 int32_t kccurjumpbackkey(<a class="code" href="structKCCUR.html">KCCUR</a>* cur, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz);
<a name="l01004"></a>01004 
<a name="l01005"></a>01005 
<a name="l01011"></a>01011 int32_t kccurstep(<a class="code" href="structKCCUR.html">KCCUR</a>* cur);
<a name="l01012"></a>01012 
<a name="l01013"></a>01013 
<a name="l01021"></a>01021 int32_t kccurstepback(<a class="code" href="structKCCUR.html">KCCUR</a>* cur);
<a name="l01022"></a>01022 
<a name="l01023"></a>01023 
<a name="l01029"></a>01029 <a class="code" href="structKCDB.html">KCDB</a>* kccurdb(<a class="code" href="structKCCUR.html">KCCUR</a>* cur);
<a name="l01030"></a>01030 
<a name="l01031"></a>01031 
<a name="l01037"></a>01037 int32_t kccurecode(<a class="code" href="structKCCUR.html">KCCUR</a>* cur);
<a name="l01038"></a>01038 
<a name="l01039"></a>01039 
<a name="l01045"></a>01045 <span class="keyword">const</span> <span class="keywordtype">char</span>* kccuremsg(<a class="code" href="structKCCUR.html">KCCUR</a>* cur);
<a name="l01046"></a>01046 
<a name="l01047"></a>01047 
<a name="l01051"></a><a class="code" href="structKCIDX.html">01051</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l01052"></a><a class="code" href="structKCIDX.html#aca889f0d26746218f782caa8d6d7b55b">01052</a>   <span class="keywordtype">void</span>* <a class="code" href="structKCIDX.html#aca889f0d26746218f782caa8d6d7b55b">db</a>;                              
<a name="l01053"></a>01053 } <a class="code" href="structKCIDX.html">KCIDX</a>;
<a name="l01054"></a>01054 
<a name="l01055"></a>01055 
<a name="l01062"></a>01062 <a class="code" href="structKCIDX.html">KCIDX</a>* kcidxnew(<span class="keywordtype">void</span>);
<a name="l01063"></a>01063 
<a name="l01064"></a>01064 
<a name="l01069"></a>01069 <span class="keywordtype">void</span> kcidxdel(<a class="code" href="structKCIDX.html">KCIDX</a>* idx);
<a name="l01070"></a>01070 
<a name="l01071"></a>01071 
<a name="l01079"></a>01079 int32_t kcidxopen(<a class="code" href="structKCIDX.html">KCIDX</a>* idx, <span class="keyword">const</span> <span class="keywordtype">char</span>* path, uint32_t mode);
<a name="l01080"></a>01080 
<a name="l01081"></a>01081 
<a name="l01087"></a>01087 int32_t kcidxclose(<a class="code" href="structKCIDX.html">KCIDX</a>* idx);
<a name="l01088"></a>01088 
<a name="l01089"></a>01089 
<a name="l01095"></a>01095 int32_t kcidxecode(<a class="code" href="structKCIDX.html">KCIDX</a>* idx);
<a name="l01096"></a>01096 
<a name="l01097"></a>01097 
<a name="l01103"></a>01103 <span class="keyword">const</span> <span class="keywordtype">char</span>* kcidxemsg(<a class="code" href="structKCIDX.html">KCIDX</a>* idx);
<a name="l01104"></a>01104 
<a name="l01105"></a>01105 
<a name="l01117"></a>01117 int32_t kcidxset(<a class="code" href="structKCIDX.html">KCIDX</a>* idx, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz, <span class="keyword">const</span> <span class="keywordtype">char</span>* vbuf, <span class="keywordtype">size_t</span> vsiz);
<a name="l01118"></a>01118 
<a name="l01119"></a>01119 
<a name="l01131"></a>01131 int32_t kcidxadd(<a class="code" href="structKCIDX.html">KCIDX</a>* idx, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz, <span class="keyword">const</span> <span class="keywordtype">char</span>* vbuf, <span class="keywordtype">size_t</span> vsiz);
<a name="l01132"></a>01132 
<a name="l01133"></a>01133 
<a name="l01145"></a>01145 int32_t kcidxreplace(<a class="code" href="structKCIDX.html">KCIDX</a>* idx, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz, <span class="keyword">const</span> <span class="keywordtype">char</span>* vbuf, <span class="keywordtype">size_t</span> vsiz);
<a name="l01146"></a>01146 
<a name="l01147"></a>01147 
<a name="l01159"></a>01159 int32_t kcidxappend(<a class="code" href="structKCIDX.html">KCIDX</a>* idx, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz, <span class="keyword">const</span> <span class="keywordtype">char</span>* vbuf, <span class="keywordtype">size_t</span> vsiz);
<a name="l01160"></a>01160 
<a name="l01161"></a>01161 
<a name="l01170"></a>01170 int32_t kcidxremove(<a class="code" href="structKCIDX.html">KCIDX</a>* idx, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz);
<a name="l01171"></a>01171 
<a name="l01172"></a>01172 
<a name="l01186"></a>01186 <span class="keywordtype">char</span>* kcidxget(<a class="code" href="structKCIDX.html">KCIDX</a>* idx, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz, <span class="keywordtype">size_t</span>* sp);
<a name="l01187"></a>01187 
<a name="l01188"></a>01188 
<a name="l01202"></a>01202 int32_t kcidxsync(<a class="code" href="structKCIDX.html">KCIDX</a>* idx, int32_t hard, KCFILEPROC proc, <span class="keywordtype">void</span>* opq);
<a name="l01203"></a>01203 
<a name="l01204"></a>01204 
<a name="l01210"></a>01210 int32_t kcidxclear(<a class="code" href="structKCIDX.html">KCIDX</a>* idx);
<a name="l01211"></a>01211 
<a name="l01212"></a>01212 
<a name="l01218"></a>01218 int64_t kcidxcount(<a class="code" href="structKCIDX.html">KCIDX</a>* idx);
<a name="l01219"></a>01219 
<a name="l01220"></a>01220 
<a name="l01226"></a>01226 int64_t kcidxsize(<a class="code" href="structKCIDX.html">KCIDX</a>* idx);
<a name="l01227"></a>01227 
<a name="l01228"></a>01228 
<a name="l01236"></a>01236 <span class="keywordtype">char</span>* kcidxpath(<a class="code" href="structKCIDX.html">KCIDX</a>* idx);
<a name="l01237"></a>01237 
<a name="l01238"></a>01238 
<a name="l01247"></a>01247 <span class="keywordtype">char</span>* kcidxstatus(<a class="code" href="structKCIDX.html">KCIDX</a>* idx);
<a name="l01248"></a>01248 
<a name="l01249"></a>01249 
<a name="l01254"></a>01254 <a class="code" href="structKCDB.html">KCDB</a>* kcidxrevealinnerdb(<a class="code" href="structKCIDX.html">KCIDX</a>* idx);
<a name="l01255"></a>01255 
<a name="l01256"></a>01256 
<a name="l01260"></a><a class="code" href="structKCMAP.html">01260</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l01261"></a><a class="code" href="structKCMAP.html#a030ea96ece49f0fe55112e1edcb87b40">01261</a>   <span class="keywordtype">void</span>* <a class="code" href="structKCMAP.html#a030ea96ece49f0fe55112e1edcb87b40">map</a>;                             
<a name="l01262"></a>01262 } <a class="code" href="structKCMAP.html">KCMAP</a>;
<a name="l01263"></a>01263 
<a name="l01264"></a>01264 
<a name="l01268"></a><a class="code" href="structKCMAPITER.html">01268</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l01269"></a><a class="code" href="structKCMAPITER.html#a63dba08f58d7add3830b49e0ffab47fc">01269</a>   <span class="keywordtype">void</span>* <a class="code" href="structKCMAPITER.html#a63dba08f58d7add3830b49e0ffab47fc">iter</a>;                            
<a name="l01270"></a>01270 } <a class="code" href="structKCMAPITER.html">KCMAPITER</a>;
<a name="l01271"></a>01271 
<a name="l01272"></a>01272 
<a name="l01276"></a><a class="code" href="structKCMAPSORT.html">01276</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l01277"></a><a class="code" href="structKCMAPSORT.html#ad61ed6705e01da5916b291e4eef04c8a">01277</a>   <span class="keywordtype">void</span>* <a class="code" href="structKCMAPSORT.html#ad61ed6705e01da5916b291e4eef04c8a">iter</a>;                            
<a name="l01278"></a>01278 } <a class="code" href="structKCMAPSORT.html">KCMAPSORT</a>;
<a name="l01279"></a>01279 
<a name="l01280"></a>01280 
<a name="l01289"></a>01289 <a class="code" href="structKCMAP.html">KCMAP</a>* kcmapnew(<span class="keywordtype">size_t</span> bnum);
<a name="l01290"></a>01290 
<a name="l01291"></a>01291 
<a name="l01296"></a>01296 <span class="keywordtype">void</span> kcmapdel(<a class="code" href="structKCMAP.html">KCMAP</a>* map);
<a name="l01297"></a>01297 
<a name="l01298"></a>01298 
<a name="l01309"></a>01309 <span class="keywordtype">void</span> kcmapset(<a class="code" href="structKCMAP.html">KCMAP</a>* map, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz, <span class="keyword">const</span> <span class="keywordtype">char</span>* vbuf, <span class="keywordtype">size_t</span> vsiz);
<a name="l01310"></a>01310 
<a name="l01311"></a>01311 
<a name="l01323"></a>01323 int32_t kcmapadd(<a class="code" href="structKCMAP.html">KCMAP</a>* map, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz, <span class="keyword">const</span> <span class="keywordtype">char</span>* vbuf, <span class="keywordtype">size_t</span> vsiz);
<a name="l01324"></a>01324 
<a name="l01325"></a>01325 
<a name="l01337"></a>01337 int32_t kcmapreplace(<a class="code" href="structKCMAP.html">KCMAP</a>* map, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz, <span class="keyword">const</span> <span class="keywordtype">char</span>* vbuf, <span class="keywordtype">size_t</span> vsiz);
<a name="l01338"></a>01338 
<a name="l01339"></a>01339 
<a name="l01350"></a>01350 <span class="keywordtype">void</span> kcmapappend(<a class="code" href="structKCMAP.html">KCMAP</a>* map, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz, <span class="keyword">const</span> <span class="keywordtype">char</span>* vbuf, <span class="keywordtype">size_t</span> vsiz);
<a name="l01351"></a>01351 
<a name="l01352"></a>01352 
<a name="l01361"></a>01361 int32_t kcmapremove(<a class="code" href="structKCMAP.html">KCMAP</a>* map, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz);
<a name="l01362"></a>01362 
<a name="l01363"></a>01363 
<a name="l01373"></a>01373 <span class="keyword">const</span> <span class="keywordtype">char</span>* kcmapget(<a class="code" href="structKCMAP.html">KCMAP</a>* map, <span class="keyword">const</span> <span class="keywordtype">char</span>* kbuf, <span class="keywordtype">size_t</span> ksiz, <span class="keywordtype">size_t</span>* sp);
<a name="l01374"></a>01374 
<a name="l01375"></a>01375 
<a name="l01380"></a>01380 <span class="keywordtype">void</span> kcmapclear(<a class="code" href="structKCMAP.html">KCMAP</a>* map);
<a name="l01381"></a>01381 
<a name="l01382"></a>01382 
<a name="l01388"></a>01388 <span class="keywordtype">size_t</span> kcmapcount(<a class="code" href="structKCMAP.html">KCMAP</a>* map);
<a name="l01389"></a>01389 
<a name="l01390"></a>01390 
<a name="l01400"></a>01400 <a class="code" href="structKCMAPITER.html">KCMAPITER</a>* kcmapiterator(<a class="code" href="structKCMAP.html">KCMAP</a>* map);
<a name="l01401"></a>01401 
<a name="l01402"></a>01402 
<a name="l01407"></a>01407 <span class="keywordtype">void</span> kcmapiterdel(<a class="code" href="structKCMAPITER.html">KCMAPITER</a>* iter);
<a name="l01408"></a>01408 
<a name="l01409"></a>01409 
<a name="l01417"></a>01417 <span class="keyword">const</span> <span class="keywordtype">char</span>* kcmapitergetkey(<a class="code" href="structKCMAPITER.html">KCMAPITER</a>* iter, <span class="keywordtype">size_t</span>* sp);
<a name="l01418"></a>01418 
<a name="l01419"></a>01419 
<a name="l01427"></a>01427 <span class="keyword">const</span> <span class="keywordtype">char</span>* kcmapitergetvalue(<a class="code" href="structKCMAPITER.html">KCMAPITER</a>* iter, <span class="keywordtype">size_t</span>* sp);
<a name="l01428"></a>01428 
<a name="l01429"></a>01429 
<a name="l01441"></a>01441 <span class="keyword">const</span> <span class="keywordtype">char</span>* kcmapiterget(<a class="code" href="structKCMAPITER.html">KCMAPITER</a>* iter, <span class="keywordtype">size_t</span>* ksp, <span class="keyword">const</span> <span class="keywordtype">char</span>** vbp, <span class="keywordtype">size_t</span>* vsp);
<a name="l01442"></a>01442 
<a name="l01443"></a>01443 
<a name="l01448"></a>01448 <span class="keywordtype">void</span> kcmapiterstep(<a class="code" href="structKCMAPITER.html">KCMAPITER</a>* iter);
<a name="l01449"></a>01449 
<a name="l01450"></a>01450 
<a name="l01460"></a>01460 <a class="code" href="structKCMAPSORT.html">KCMAPSORT</a>* kcmapsorter(<a class="code" href="structKCMAP.html">KCMAP</a>* map);
<a name="l01461"></a>01461 
<a name="l01462"></a>01462 
<a name="l01467"></a>01467 <span class="keywordtype">void</span> kcmapsortdel(<a class="code" href="structKCMAPSORT.html">KCMAPSORT</a>* sort);
<a name="l01468"></a>01468 
<a name="l01469"></a>01469 
<a name="l01477"></a>01477 <span class="keyword">const</span> <span class="keywordtype">char</span>* kcmapsortgetkey(<a class="code" href="structKCMAPSORT.html">KCMAPSORT</a>* sort, <span class="keywordtype">size_t</span>* sp);
<a name="l01478"></a>01478 
<a name="l01479"></a>01479 
<a name="l01487"></a>01487 <span class="keyword">const</span> <span class="keywordtype">char</span>* kcmapsortgetvalue(<a class="code" href="structKCMAPSORT.html">KCMAPSORT</a>* sort, <span class="keywordtype">size_t</span>* sp);
<a name="l01488"></a>01488 
<a name="l01489"></a>01489 
<a name="l01501"></a>01501 <span class="keyword">const</span> <span class="keywordtype">char</span>* kcmapsortget(<a class="code" href="structKCMAPSORT.html">KCMAPSORT</a>* sort, <span class="keywordtype">size_t</span>* ksp, <span class="keyword">const</span> <span class="keywordtype">char</span>** vbp, <span class="keywordtype">size_t</span>* vsp);
<a name="l01502"></a>01502 
<a name="l01503"></a>01503 
<a name="l01508"></a>01508 <span class="keywordtype">void</span> kcmapsortstep(<a class="code" href="structKCMAPSORT.html">KCMAPSORT</a>* sort);
<a name="l01509"></a>01509 
<a name="l01510"></a>01510 
<a name="l01514"></a><a class="code" href="structKCLIST.html">01514</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l01515"></a><a class="code" href="structKCLIST.html#ab645950cc959a3f9d367fa6c56ef4a71">01515</a>   <span class="keywordtype">void</span>* <a class="code" href="structKCLIST.html#ab645950cc959a3f9d367fa6c56ef4a71">list</a>;                            
<a name="l01516"></a>01516 } <a class="code" href="structKCLIST.html">KCLIST</a>;
<a name="l01517"></a>01517 
<a name="l01518"></a>01518 
<a name="l01525"></a>01525 <a class="code" href="structKCLIST.html">KCLIST</a>* kclistnew();
<a name="l01526"></a>01526 
<a name="l01527"></a>01527 
<a name="l01532"></a>01532 <span class="keywordtype">void</span> kclistdel(<a class="code" href="structKCLIST.html">KCLIST</a>* list);
<a name="l01533"></a>01533 
<a name="l01534"></a>01534 
<a name="l01541"></a>01541 <span class="keywordtype">void</span> kclistpush(<a class="code" href="structKCLIST.html">KCLIST</a>* list, <span class="keyword">const</span> <span class="keywordtype">char</span>* buf, <span class="keywordtype">size_t</span> size);
<a name="l01542"></a>01542 
<a name="l01543"></a>01543 
<a name="l01549"></a>01549 int32_t kclistpop(<a class="code" href="structKCLIST.html">KCLIST</a>* list);
<a name="l01550"></a>01550 
<a name="l01551"></a>01551 
<a name="l01558"></a>01558 <span class="keywordtype">void</span> kclistunshift(<a class="code" href="structKCLIST.html">KCLIST</a>* list, <span class="keyword">const</span> <span class="keywordtype">char</span>* buf, <span class="keywordtype">size_t</span> size);
<a name="l01559"></a>01559 
<a name="l01560"></a>01560 
<a name="l01566"></a>01566 int32_t kclistshift(<a class="code" href="structKCLIST.html">KCLIST</a>* list);
<a name="l01567"></a>01567 
<a name="l01568"></a>01568 
<a name="l01577"></a>01577 <span class="keywordtype">void</span> kclistinsert(<a class="code" href="structKCLIST.html">KCLIST</a>* list, <span class="keyword">const</span> <span class="keywordtype">char</span>* buf, <span class="keywordtype">size_t</span> size, <span class="keywordtype">size_t</span> idx);
<a name="l01578"></a>01578 
<a name="l01579"></a>01579 
<a name="l01585"></a>01585 <span class="keywordtype">void</span> kclistremove(<a class="code" href="structKCLIST.html">KCLIST</a>* list, <span class="keywordtype">size_t</span> idx);
<a name="l01586"></a>01586 
<a name="l01587"></a>01587 
<a name="l01596"></a>01596 <span class="keyword">const</span> <span class="keywordtype">char</span>* kclistget(<a class="code" href="structKCLIST.html">KCLIST</a>* list, <span class="keywordtype">size_t</span> idx, <span class="keywordtype">size_t</span>* sp);
<a name="l01597"></a>01597 
<a name="l01598"></a>01598 
<a name="l01603"></a>01603 <span class="keywordtype">void</span> kclistclear(<a class="code" href="structKCLIST.html">KCLIST</a>* list);
<a name="l01604"></a>01604 
<a name="l01605"></a>01605 
<a name="l01611"></a>01611 <span class="keywordtype">size_t</span> kclistcount(<a class="code" href="structKCLIST.html">KCLIST</a>* list);
<a name="l01612"></a>01612 
<a name="l01613"></a>01613 
<a name="l01614"></a>01614 <span class="preprocessor">#if defined(__cplusplus)</span>
<a name="l01615"></a>01615 <span class="preprocessor"></span>}
<a name="l01616"></a>01616 <span class="preprocessor">#endif</span>
<a name="l01617"></a>01617 <span class="preprocessor"></span>
<a name="l01618"></a>01618 <span class="preprocessor">#endif                                   </span><span class="comment">/* duplication check */</span>
<a name="l01619"></a>01619 
<a name="l01620"></a>01620 <span class="comment">/* END OF FILE */</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 19:00:22 for RevDedup by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
